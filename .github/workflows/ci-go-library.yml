name: CI

on:
  workflow_call:
    inputs:
      localstack_version:
        type: string
        required: false
        default: "latest"
        description: "LocalStack version to use (e.g., '3.0.2', 'latest')"
    secrets:
      go-private-modules-pat:
        required: true

jobs:
  ci:
    runs-on: ubuntu-latest
    env:
      LOCALSTACK_VERSION: ${{ inputs.localstack_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup access to private Go modules
        env:
          GO_PRIVATE_MODULES_PAT: ${{ secrets.go-private-modules-pat }}
        run: |
          git config --global \
            url."https://understory-services:${GO_PRIVATE_MODULES_PAT}@github.com/understory-io".insteadOf \
            "https://github.com/understory-io"

      # Go caching strategy is based on https://danp.net/posts/github-actions-go-cache/
      - name: Restore Go cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          # always grab from the restore-keys pattern below,
          # like Linux-go-$hash-YYYY-MM-DD as saved by CI
          key: nonexistent
          restore-keys: ${{ runner.os }}-go-${{ hashFiles('go.mod') }}-

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false

      # Set up Docker Buildx for caching
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Login to GitHub Container Registry for caching
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Setup LocalStack with registry caching
      - name: Setup LocalStack with registry caching
        run: |
          CACHE_VERSION="${LOCALSTACK_VERSION:-latest}"
          ORIGINAL_IMAGE="localstack/localstack:${CACHE_VERSION}"
          CACHED_IMAGE="ghcr.io/${{ github.repository }}/localstack-cache:${CACHE_VERSION}"

          echo "ORIGINAL_IMAGE=${ORIGINAL_IMAGE}" >> $GITHUB_ENV
          echo "CACHED_IMAGE=${CACHED_IMAGE}" >> $GITHUB_ENV

          echo "Attempting to pull cached LocalStack image from GHCR..."
          if timeout 60s docker pull "${CACHED_IMAGE}" 2>/dev/null; then
            echo "✅ Found cached image in GHCR, retagging as original"
            docker tag "${CACHED_IMAGE}" "${ORIGINAL_IMAGE}"
            echo "LOCALSTACK_READY=true" >> $GITHUB_ENV
          else
            echo "❌ Cache miss or timeout, trying direct pull..."
            if timeout 120s docker pull "${ORIGINAL_IMAGE}" 2>/dev/null; then
              echo "✅ Successfully pulled original image"
              # Cache it for next time (non-blocking)
              echo "Caching image to GHCR for future runs..."
              docker tag "${ORIGINAL_IMAGE}" "${CACHED_IMAGE}"
              timeout 120s docker push "${CACHED_IMAGE}" 2>/dev/null || echo "⚠️ Failed to cache image, continuing anyway"
              echo "LOCALSTACK_READY=true" >> $GITHUB_ENV
            else
              echo "❌ Failed to pull LocalStack image"
              echo "LOCALSTACK_READY=false" >> $GITHUB_ENV
            fi
          fi

      - name: Verify LocalStack image
        run: |
          echo "Verifying LocalStack image..."
          docker images | grep localstack || echo "No LocalStack image found"

          if [ "$LOCALSTACK_READY" != "true" ]; then
            echo "❌ LocalStack not ready, tests may fail"
            exit 1
          fi

      - name: Pull dependencies
        run: |
          go mod download -x

      - name: Build
        run: |
          export GOFLAGS="-mod=readonly"
          make build

      - name: Test
        run: |
          export GOFLAGS="-mod=readonly"
          make test
        env:
          AWS_ACCESS_KEY_ID: test
          AWS_SECRET_ACCESS_KEY: test
          LOCALSTACK_VERSION: ${{ env.LOCALSTACK_VERSION }}

        # experimental improved cache strategy
      - name: Trim Go cache
        if: ${{ github.ref == 'refs/heads/main' }}
        shell: bash
        # As the go command works, it either creates build cache files or touches
        # ones it uses at most once an hour. When it trims the cache, it trims
        # files that have not been modified/touched in 5+ days.
        # To keep our saved cache lean, trim all files except ones that were just
        # created/touched as part of this run.
        run: |
          find ~/.cache/go-build -type f -mmin +90 -delete

      - name: Set Go cache date
        shell: bash
        run: echo "GO_CACHE_DATE=$(date +%Y-%m-%d)" >> $GITHUB_ENV

      - name: Save Go cache
        if: ${{ github.ref == 'refs/heads/main' }}
        uses: actions/cache/save@v4
        with:
          # Caches both the downloaded modules and the compiled build cache.
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          # Save to eg Linux-go-$hash-YYYY-MM-DD to keep the cache fresh
          key: "${{ runner.os }}-go-${{ hashFiles('go.mod') }}-${{ env.GO_CACHE_DATE }}"
